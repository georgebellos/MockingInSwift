{
  "name": "Mockinginswift",
  "tagline": "Mocking in Swift",
  "body": "To Kill a Mocking Bird\r\n======================\r\n## Mocking in Swift ##\r\n\r\nMocking in Swift is hard. Mocking frameworks traditionally depend on a number of language features to do their work. They typically need to ensure that a mock object is interchangeable with a real object and they need to intercept method calls to be able to record the fact that they were called.\r\n\r\nSo in languages like Javascript or Ruby which have no compile time type checking of and allow any method call to be intercepted, writing a mocking framework is almost a trivial exercise. With Swifts heavy static type checking and no way to intercept method calls, mocking becomes troublesome.\r\n\r\nThis explains the absence of mocking frameworks in Swift. But not all is lost. We will expand upon a number of techniques that, although they are a bit more cumbersome than simply using a mocking framework, will allow you to create mocks in your tests.\r\n\r\n### Your own classes ###\r\n\r\nThere is a relatively easy way to mock classes in Swift when they are under your control. Let’s assume that we are writing an app that talks to a backend using a class called ‘Backend’:\r\n\r\n```swift\r\nclass Backend {\r\n    func storeItem(item: Item) {\r\n        // makes http POST call\r\n    }\r\n}\r\n\r\nclass Item {}\r\n```\r\n\r\nIf we wish to mock this class then all we have to do is extract a protocol, and ensure that we use the protocol instead of the class throughout the app:\r\n\r\n```swift\r\nprotocol BackendType {\r\n    func storeItem(item: Item)\r\n}\r\n\r\nextension Backend : BackendType {}\r\n```\r\n\r\nIn your tests you can now introduce a mock variant of the Backend by providing a second implementation of the BackendType protocol:\r\n\r\n```swift\r\nclass BackendMock : BackendType {\r\n    var latestItem: Item?\r\n\r\n    func storeItem(item: Item) {\r\n        latestItem = item\r\n    }\r\n}\r\n```\r\n\r\nNotice that it now become easy to introduce a method that checks that the storeItem method was called with the correct parameter:\r\n\r\n```swift\r\nimport XCTest\r\n\r\nextension BackendMock {\r\n    func verifyLatestItemEquals(expected: Item) {\r\n        XCTAssertTrue(latestItem === expected)\r\n    }\r\n}\r\n```\r\n\r\nFor more about introducing protocols in your code and why that is such a good idea, I refer you to the excellent [WWDC video about Protocol Oriented Programming in Swift](https://developer.apple.com/videos/play/wwdc2015/408/).\r\n\r\n### Third party classes ###\r\n\r\nThings become a bit more complex when the classes that you want to mock are not under your control. For instance when you want to mock a class from a system library.\r\n\r\nLet’s assume that we wish to use Apple’s Core Bluetooth framework. It contains a class called CBCentralManager, which has a method for connecting to a Bluetooth peripheral:\r\n\r\n```swift\r\nfunc connectPeripheral(peripheral: CBPeripheral,\r\n                           options: [String : AnyObject]?)\r\n```\r\n\r\nIf we were to apply the same strategy as before, we would extract a protocol from CBPeripheral and change the signature of the connectPeripheral method such that the type of the peripheral parameter is no longer a class but a protocol.\r\n\r\nBecause both the CBCentralManager class and the CBPeripheral class are part of Apple’s framework, we cannot do that.\r\n\r\nLuckily there are two strategies that we can apply.\r\n\r\n### Wrapping ###\r\n\r\nA standard technique when dealing with hard-to-mock classes is to wrap them. In Swift we can use a slightly nicer variation using extensions.\r\n\r\nIn our Bluetooth example we would first extract a protocol for CBPeripheral:\r\n\r\n```swift\r\nimport CoreBluetooth\r\n\r\nprotocol CBPeripheralType: class {}\r\n\r\nextension CBPeripheral: CBPeripheralType {}\r\n```\r\n\r\nThen we extract a protocol for CBCentralManager where we take care to replace the occurrence of CBPeripheral with CBPeripheralType:\r\n\r\n```swift\r\nprotocol CBCentralManagerType {\r\n    func connectPeripheral(peripheral: CBPeripheralType, options: [String: AnyObject]?)\r\n}\r\n```\r\n\r\nBy wrapping the connectPeripheral method we ensure that CBCentralManager conforms to the new protocol:\r\n\r\n```swift\r\nextension CBCentralManager: CBCentralManagerType {\r\n    func connectPeripheral(peripheral: CBPeripheralType, options: [String: AnyObject]?) {\r\n        if let realPeripheral = peripheral as? CBPeripheral {\r\n            connectPeripheral(realPeripheral, options: options)\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nNow we are free to introduce mocks for both CBCentralManager and CBPeripheral:\r\n\r\n```swift\r\nclass CBPeripheralMock: CBPeripheralType {}\r\n\r\nclass CBCentralManagerMock: CBCentralManagerType {\r\n    var latestPeripheral: CBPeripheralType?\r\n\r\n    func connectPeripheral(peripheral: CBPeripheralType, options: [String : AnyObject]?) {\r\n            latestPeripheral = peripheral\r\n    }\r\n}\r\n```\r\n\r\nAnd we can create a method for checking that the correct peripheral was connected:\r\n\r\n```swift\r\nextension CBCentralManagerMock {\r\n    func verifyLatestPeripheralEquals(expected: CBPeripheralType) {\r\n        XCTAssertTrue(latestPeripheral === expected)\r\n    }\r\n}\r\n```\r\n\r\n### Cheating ###\r\n\r\nShould you wish to avoid introducing protocols for all classes in a third-party framework then there’s another option. You can create your mocks in Objective-C using a mocking framework. This  could be considered cheating because it is not a pure Swift solution and it will not work for mocking pure Swift frameworks.\r\n\r\nBut sometimes cheating is a winning strategy.\r\n\r\nGoing back to our Bluetooth example, we will introduce a mock for CBPeripheral in Objective-C using the [OCMockito framework](https://github.com/jonreid/OCMockito):\r\n\r\n```objective-c\r\n@import OCMockito;\r\n@import CoreBluetooth;\r\n\r\n@interface CBPeripheralMock: NSObject\r\n@property(readonly, nonatomic) CBPeripheral *mock;\r\n@end\r\n\r\n@implementation CBPeripheralMock\r\n\r\n- (instancetype)init\r\n{\r\n    self = [super init];\r\n    if (self) {\r\n        _mock = mock(CBPeripheral.class);\r\n    }\r\n    return self;\r\n}\r\n@end\r\n```\r\n\r\nAnd also a mock for the CBCentralManager:\r\n\r\n```objective-c\r\n@import OCMockito\r\n@import OCHamcrest;\r\n@import CoreBluetooth;\r\n\r\n@interface CBCentralManagerMock: NSObject\r\n@property(readonly, nonatomic) CBCentralManager *mock;\r\n@end\r\n\r\n@implementation CBCentralManagerMock\r\n- (instancetype)init {\r\n    _mock = mock(CBCentralManagerMock.class)\r\n}\r\n\r\n- (void)verifyPeripheralEquals:(CBPeripheral *) expected  {\r\n    [verify(self.mock) connectPeripheral:expected\r\n                                 options:anything()]\r\n}\r\n@end\r\n```\r\n\r\nUsing this small Objective-C layer we are now free to write the rest of the test in Swift.\r\n\r\nNotice that the mock class does not inherit from the class that it is mocking. Therefore it cannot be directly used in places where the real class is expected. In your tests you would use the mock property to get to the actual mock.\r\n### Thanks ###\r\n\r\nMany thanks to my colleagues Berik, Derk & XiaoChen for exploring these solutions with me.\r\n\r\nMark Spanbroek, 2016-08-04",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}